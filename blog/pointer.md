---
title: Golang Pointer
slug: Pointer
tags: [goland, pointer]
---

在操作系统里，一个内存地址用一个操作系统原生字（native word）存储，一个原生字在32位操作系统上占4个字节，在64位操作系统上占8个字节。

所以，32位操作系统上的理论最大支持内存容量为4GB（1GB == 230字节），64位操作系统上的理论最大支持内存容量为264Byte，即16EB（EB：艾字节，1EB == 1024PB, 1PB == 1024TB, 1TB == 1024GB）。

### 概念

指针是Go中的一种类型分类（kind）。 一个指针可以存储一个内存地址；

在Go中，一个**无名指针类型**的字面形式为`*T`，其中T为一个任意类型。类型T称为指针类型`T`的基类型（base type）。 如果一个指针类型的基类型为T，则我们可以称此指针类型为一个T指针类型。

如果两个无名指针类型的基类型为同一类型，则这两个无名指针类型亦为同一类型。


### 关于引用 reference

如果一个指针中存储着另外一个值的地址，则我们可以说此指针值引用着另外一个值；同时另外一个值当前至少有一个引用。  
当一个指针引用着另外一个值，我们也常说此指针指向另外一个值

### 如何获取一个指针值

有两个办法

- 用 new 来为任何类型的值开辟一块内存并将此内存块的地址作为此值的地址返回。假设 T 是任一类型，则函数调用 new(T) 返回一个
类型为 *T 的指针值。存储在返回指针值所表示的地址处的值（匿名变量）为 T 的零值
- 使用前置去地址操作符 & 来获取一个可寻址的值的地址。对于一个类型为 T 的可寻址的变量 t，我们可以用 &t 来取得他的地址，&t 的类型为 *T

talk is cheap，show you the code

```go
package main

import "fmt"

func main() {
	p0 := new(int)   // p0指向一个int类型的零值
	fmt.Println(p0)  // （打印出一个十六进制形式的地址）
	fmt.Println(*p0) // 0

	x := *p0              // x是p0所引用的值的一个复制。
	p1, p2 := &x, &x      // p1和p2中都存储着x的地址。
	                      // x、*p1和*p2表示着同一个int值。
	fmt.Println(p1 == p2) // true
	fmt.Println(p0 == p1) // false
	p3 := &*p0            // <=> p3 := &(*p0)
	                      // <=> p3 := p0
	                      // p3和p0中存储的地址是一样的。
	fmt.Println(p0 == p3) // true
	*p0, *p1 = 123, 789
	fmt.Println(*p2, x, *p3) // 789 789 123

	fmt.Printf("%T, %T \n", *p0, x) // int, int
	fmt.Printf("%T, %T \n", p0, p1) // *int, *int
}
```

### 为什么需要指针

比如这样
```go
package main

import "fmt"

func double(x int) {
	x += x
}

func main() {
	var a = 3
	double(a)
	fmt.Println(a) // 3
}
```
我们本期望上例中的`double`函数将变量`a`的值放大为原来的两倍，但是事实证明我们的期望没有得到实现。 为什么呢？因为在Go中，所有的赋值（包括函数调用传参）过程都是一个值复制过程。 所以在上面的`double`函数体内修改的是变量`a`的一个副本，而没有修改变量`a`本身。

当然我们可以让`double`函数返回输入参数的两倍数，但是此方法并非适用于所有场合。 下面这个例子通过将输入参数的类型改为一个指针类型来达到同样的目的。


```go
package main

import "fmt"

func double(x *int) {
	*x += *x
	x = nil // 此行仅为讲解目的
}

func main() {
	var a = 3
	double(&a)
	fmt.Println(a) // 6
	p := &a
	double(p)
	fmt.Println(a, p == nil) // 12 false
}
```
从上例可以看出，通过将`double`函数的输入参数的类型改为`*int`，传入的实参`&a`和它在此函数体内的一个副本`x`都引用着变量`a`。 所以对`*x`的修改等价于对`*p`（也就是变量`a`）的修改。 换句话说，新版本的`double`函数内的操作可以反映到此函数外了。

当然，在此函数体内对传入的指针实参的修改`x = nil`依旧不能反映到函数外，因为此修改发生在此**指针的一个副本**上。 所以在`double`函数调用之后，局部变量`p`的值并没有被修改为`nil`。

简而言之，指针提供了一种间接的途径来访问和修改一些值。 虽然很多语言中没有指针这个概念，但是指针被隐藏其它概念之中。


[学习链接](https://gfw.go101.org/article/pointer.html)