---
title: Golang introduction
slug: goland
tags: [goland, project]
---

## 架构如何分层

**按功能模块划分**

一个订单系统，我们可以根据不同功能将其拆分成用户（user）、订单（order）和计费（billing）3 个模块， 每一个模块提供独立的功能，功能更单一：

![go_project](https://raw.githubusercontent.com/GyuXiao/GyuBlogImage/main/data/go_project.png)

该订单的代码目录结构：

```
$ tree pkg
$ tree --noreport -L 2 pkg
pkg
├── billing
├── order
│   └── order.go
└── user
```

按功能模块划分的优点：

- 不同模块，功能单一，可以实现高内聚低耦合的设计哲学
- 因为所有的功能只需要实现一次，引用逻辑清晰，会大大减少出现循环引用的概率

## 如何进行单元测试

如果我们要对函数 A 进行测试，并且 A 中的所有代码均能够在单元测试环境下按预期被执行，那么函数 A 的代码块就是可测试的。我们来看下一般的单元测试环境有什么特点：

- 可能无法连接数据库
- 可能无法访问第三方服务

如果函数 A 依赖数据库连接、第三方服务，那么在单元测试环境下执行单元测试就会失败，函数就没法测试，函数是不可测的

解决方法也很简单：将依赖的数据库、第三方服务等抽象成接口，在被测代码中调用接口的方法，在测试时传入 mock 类型，从而将数据库、第三方服务等依赖从具体的被测函数中解耦出去。如下图所示：

![design_function](https://raw.githubusercontent.com/GyuXiao/GyuBlogImage/main/data/design_function.png)

为了提高代码的可测性，降低单元测试的复杂度，对 function 和 mock 的要求是：

- 要尽可能减少 function 中的依赖，让 function 只依赖必要的模块。编写一个功能单一、职责分明的函数，会有利于减少依赖
- 依赖模块应该是易 Mock 的。

不可测试的代码，像下面这样：

```go
package post

import "google.golang.org/grpc"

type Post struct {
	Name    string
	Address string
}

func ListPosts(client *grpc.ClientConn) ([]*Post, error) {
	return client.ListPosts()
}
```

因为 ListPosts 函数中调用了client.ListPosts()方法， 该方法依赖于一个 gRPC 连接。而我们在做单元测试时，可能因为没有配置 gRPC 服务的地址、网络隔离等原因， 导致没法建立 gRPC 连接，从而导致
ListPosts 函数执行失败。

改成可测试的代码，如下：

```go
package main

type Post struct {
	Name    string
	Address string
}

type Service interface {
	ListPosts() ([]*Post, error)
}

func ListPosts(svc Service) ([]*Post, error) {
	return svc.ListPosts()
}
```

`ListPosts` 函数的**入参**为 Service **接口类型**， 只要传入一个**实现** Service 接口类型的实例，`ListPosts` 函数即可成功运行。

```go
// 下面是测试代码
package main

import "testing"

type fakeService struct {
}

func NewFakeService() Service {
	return &fakeService{}
}

func TestListPosts(t *testing.T) {
	fake := NewFakeService()
	if _, err := ListPosts(fake); err != nil {
		t.Fatal("list posts failed")
	}
}

func (s *fakeService) ListPosts() ([]*Post, error) {
	posts := make([]*Post, 0)
	posts = append(posts, &Post{
		Name:    "colin",
		Address: "Shenzhen",
	})
	posts = append(posts, &Post{
		Name:    "alex",
		Address: "Beijing",
	})
	return posts, nil
}

```

因此，我们可以在单元测试中实现一个不依赖于任何第三方服务的 fake 实例，并传给`ListPosts`。

## 编程哲学

面向接口编程 和 面向"对象"编程


### 面向接口编程
Go 接口是一组方法的集合。任何类型，只要实现了该接口中的方法集，那么就属于这个类型，也称为实现了该接口。

接口的作用，其实就是为不同层级的模块提供一个定义好的中间层。

这样，上游不再需要依赖下游的具体实现，充分地对上下游进行了解耦。

> talk is cheap，show you the code

```go
package main

import "fmt"

type Bird interface {
	Fly()
	Type() string
}

type Canary struct {
	Name string
}

func (c *Canary) Fly() {
	fmt.Printf("I am %s with yellow wing\n", c.Name)
}

func (c *Canary) Type() string {
	return c.Name
}

type Crow struct {
	Name string
}

func (c *Crow) Fly() {
	fmt.Printf("I am %s with black wing\n", c.Name)
}

func (c *Crow) Type() string {
	return c.Name
}

func letItFly(bird Bird) {
	fmt.Printf("Let %s Fly\n", bird.Type())
	bird.Fly()
}

func main() {
	letItFly(&Canary{"Canary"})
	letItFly(&Canary{"Crow"})
}
```

## 小结
### 使用接口的好处
- 代码扩展性更强了。例如，同样的 Bird，可以有不同的实现。在开发中用的更多的是，将数据库的 CURD 操作抽象成接口，从而可以实现同一份代码对接不同数据库的目的。
- 可以解耦上下游的实现。例如，LetItFly 不用关注 Bird 是如何 Fly 的，只需要调用 Bird 提供的方法即可。
- 提高了代码的可测性。因为接口可以解耦上下游实现，我们在单元测试需要依赖第三方系统 / 数据库的代码时，可以利用接口将具体实现解耦，实现 fake 类型。
- 代码更健壮、更稳定了。例如，如果要更改 Fly 的方式，只需要更改相关类型的 Fly 方法即可，完全影响不到 LetItFly 函数。

### 面向"对象"编程

在 Go 中的样子

- 类、抽象、封装，通过`结构体`来实现
- 实例通过`结构体变量`来实现
- 继承通过`组合`来实现（组合：一个结构体嵌到另一个结构体，比如，一个结构体包含了一个匿名结构体，就说这个结构体组合了该匿名结构体）
- 多态通过`接口`来实现 

![oop_go](https://raw.githubusercontent.com/GyuXiao/GyuBlogImage/main/data/20220509134724.png)

talk is cheap, show you the code
```go
package main

import "fmt"

// 基类：Bird
type Bird struct {
	Type string
}

// 鸟的类别
func (bird *Bird) Class() string {
	return bird.Type
}

// 定义了一个鸟类
type Birds interface {
	Name() string
	Class() string
}

// 两点说明：
//（1）分别通过 Canary 和 Crow 结构体定义了两种类别的鸟，其中分别封装 name 属性 和 Name 方法；换句话说，是用结构体完成了一个类的编写，该类抽象了鸟类，并封装类该鸟类的属性和方法
//（2）在 Canary 和 Crow 结构体中，都有一个 Bird 匿名字段，Bird 字段是 Canary 和 Crow 的父类，Canary 和 Crow 继承了 Bird 类的 Class 属性和方法；换句话说，通过匿名字段完成了继承
// 鸟类：金丝雀
type Canary struct {
	Bird
	name string
}

func (c *Canary) Name() string {
	return c.name
}

// 鸟类：乌鸦
type Crow struct {
	Bird
	name string
}

func (c *Crow) Name() string {
	return c.name
}

// new 一个 Crow 实例
func NewCrow(name string) *Crow {
	return &Crow{
		Bird: Bird{
			Type: "Crow",
		},
		name: name,
	}
}

// new 一个 Canary 实例
func NewCanary(name string) *Canary {
	return &Canary{
		Bird: Bird{
			Type: "Canary",
		},
		name: name,
	}
}

// 在 BirdInfo 函数中，将 Birds 接口类型作为参数传入，并在函数中调用 birds.Name, birds.Class 方法，这两个方法会根据 birds 类别的不同而返回不同的名字和类型，换句话说，通过接口完成了多态
func BirdInfo(birds Birds) {
	fmt.Printf("I'm %s, I belong to %s bird class!\n", birds.Name(), birds.Class())
}

// 在 main 函数中，通过 NewCanary 创建了 Canary 鸟类实例，并将其传给 BirdInfo 函数，换句话说，通过结构体变量完成了实例
func main() {
	canary := NewCanary("CanaryA")
	BirdInfo(canary)

	crow := NewCrow("CrowA")
	BirdInfo(crow)
}
```
